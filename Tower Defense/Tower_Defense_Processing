import processing.serial.*;

PImage Fly;
PImage LilyPad1;
PImage LilyPad2;
PImage LilyPad3;
PImage LilyPad4;

Serial serialPort;

int NUM_OF_VALUES_FROM_PROCESSING = 2;
int processing_values[] = new int[NUM_OF_VALUES_FROM_PROCESSING];

int NUM_OF_VALUES_FROM_ARDUINO = 16;
int NUM_SPACES = 4;
int BREAKPOINT = 4;
int arduino_values[] = new int[NUM_OF_VALUES_FROM_ARDUINO];
int board_state[][] = new int[BREAKPOINT][NUM_SPACES];

ArrayList<Enemy> enemies;
int spawnTimer = 0;
int spawnInterval = 30;

ArrayList<Tower> towers;

int nexusX, nexusY;
int nexusHealth = 3;
int nexusRadius = 50;

boolean receiving = false;

int startTime; //Start time of current run
void setup() {
  Fly = loadImage("Fly.png");
  Fly.resize(50, 50);

  LilyPad1 = loadImage("LilyPad1.png");
  LilyPad1.resize(50, 50);

  LilyPad2 = loadImage("LilyPad2.png");
  LilyPad2.resize(50, 50);

  LilyPad3 = loadImage("LilyPad3.png");
  LilyPad3.resize(50, 50);

  LilyPad4 = loadImage("LilyPad4.png");
  LilyPad4.resize(50, 50);

  size(800, 800);
  background(0);
  enemies = new ArrayList<Enemy>();
  towers = new ArrayList<Tower>();

  nexusX = width/2;
  nexusY = height/2;

  printArray(Serial.list());
  serialPort = new Serial(this, "/dev/cu.usbmodem101", 9600);
}

void draw() {
  if (!receiving) {
    if (serialPort.available() > 0) {
      String in = serialPort.readStringUntil(10);
      if (in != null) {
        receiving = true;
        startTime = millis();
      }
    }
  }
  if (receiving) {
    background(255);
    stroke(255);
    fill(255);
    int m = millis();

    //for (int i = 0; i < BREAKPOINT; i++) {
    //  for (int j = 0; j < NUM_SPACES; j++) {
    //    board_state[i][j] = 1;
    //  }
    //}

    getSerialData();
    int count = 0;
    for (int i = 0; i < 4; i++) {
      for (int j = 0; j < 4; j++) {
        if (arduino_values[count] == 1) {
          board_state[i][j] = 1;
        } else {
          board_state[i][j] = 0;
        }
        count++;
      }
    }

    int incrementX = width/(NUM_SPACES+1);
    int incrementY = height/(NUM_SPACES+1);
    for (int i = 0; i < BREAKPOINT; i++) {
      for (int j = 0; j < NUM_SPACES; j++) {
        if (board_state[i][j] == 1) {
          int x = incrementX * (j+1);
          int y = incrementY * (i+1);
          towers.add(new Tower(x, y));
          circle(x, y, 20);
        }
      }
    }

    //NEXUS
    fill(0, 200, 255);
    ellipse(nexusX, nexusY, nexusRadius*2, nexusRadius*2);
    fill(255);
    textAlign(CENTER);
    textSize(12);
    text("Nexus", nexusX, nexusY+4);

    //HEALTH INFO
    for (int i = 0; i < nexusHealth; i++) {
      fill(255, 0, 0);
      heart(20 + i*30, height - 20, 10);
    }

    spawnTimer++;
    if (spawnTimer >= spawnInterval) {
      enemies.add(spawnEnemy());
      spawnTimer = 0;
    }

    for (int i = enemies.size() - 1; i >= 0; i--) {
      Enemy e = enemies.get(i);
      e.update();
      e.display();

      if (dist(e.x, e.y, nexusX, nexusY) < nexusRadius) {
        nexusHealth--;
        enemies.remove(i);
        if (nexusHealth <= 0) {
          fill(#FF0000);
          circle(width/2, height/2, 5000);
          fill(0);
          textSize(100);
          text("Game Over!", width/2, height/2);
          println("Game Over!");
          processing_values[0] = 1;
          int time = millis();
          processing_values[1] = (time - startTime);
          sendSerialData();
          receiving = false;
          noLoop();
        }
      }
    }
    if (m>=30000) {
      spawnInterval = 0;
    } else if (m>=20000) {
      spawnInterval = 10;
    } else if (m>=10000) {
      spawnInterval = 20;
    }
    updateTowers();
  }
}

//ENEMY
Enemy spawnEnemy() {
  float x, y;
  int side = int(random(4)); // 0: TOP, 1: RIGHT, 2: LEFT, 3: BOTTOM
  if (side == 0) {
    x = random(width);
    y = 0;
  } else if (side == 1) {
    x = width;
    y = random(height);
  } else if (side == 2) {
    x = 0;
    y = random(height);
  } else {
    x = random(width);
    y = height;
  }
  return new Enemy(x, y, nexusX, nexusY);
}

class Enemy {
  float x, y;
  float targetX, targetY;
  float speed = 5;
  float dx, dy;

  Enemy(float startX, float startY, float tx, float ty) {
    x = startX;
    y = startY;
    targetX = tx;
    targetY = ty;

    float angle = atan2(targetY - y, targetX - x);
    dx = cos(angle) * speed;
    dy = sin(angle) * speed;
  }

  void update() {
    x += dx;
    y += dy;
  }

  void display() {
    image(Fly, x, y);
  }
}

//TOWERS
void updateTowers() {
  int incrementX = width/(NUM_SPACES+1);
  int incrementY = height/(NUM_SPACES+1);

  towers.clear();

  for (int i = 0; i < BREAKPOINT; i++) {
    for (int j = 0; j < NUM_SPACES; j++) {
      if (board_state[i][j] == 1) {
        int x = incrementX * (j+1);
        int y = incrementY * (i+1);
        towers.add(new Tower(x, y));
      }
    }
  }

  for (Tower t : towers) {
    t.display();
    t.shoot(enemies);
  }
}

class Tower {
  float x, y;
  float range = width/10;
  int cooldown = 0;
  int cooldownTime = 30; // frames between shots

  Tower(float tx, float ty) {
    x = tx;
    y = ty;
  }

  void display() {
    //int r = int(random(1, 5));
    //if (r == 1) {
    //  image(LilyPad1, x - 25, y - 25);
    //} else if (r == 2) {
    //  image(LilyPad2, x - 25, y - 25);
    //} else if (r ==3 ) {
    //  image(LilyPad3, x - 25, y - 25);
    //} else {
    image(LilyPad4, x - 25, y - 25);
    //}

    noFill();
    stroke(0, 255, 0, 100);
    ellipse(x, y, range*2, range*2);
  }

  void shoot(ArrayList<Enemy> enemies) {
    if (cooldown > 0) {
      cooldown--;
      return;
    }
    for (int i = 0; i < enemies.size(); i++) {
      Enemy e = enemies.get(i);
      float d = dist(x, y, e.x, e.y);
      if (d < range) {
        enemies.remove(i);
        cooldown = cooldownTime;
        break;
      }
    }
  }
}

//HEARTS
void heart(float x, float y, float size) {
  beginShape();
  vertex(x, y);
  bezierVertex(x - size/2, y - size/2, x - size, y + size/3, x, y + size);
  bezierVertex(x + size, y + size/3, x + size/2, y - size/2, x, y);
  endShape(CLOSE);
}

//ARDUINO INPUT
void getSerialData() {
  while (serialPort.available() > 0) {
    String in = serialPort.readStringUntil(10);
    if (in != null) {
      print("From Arduino: " + in);
      String[] serialInArray = split(trim(in), ",");
      if (serialInArray.length == NUM_OF_VALUES_FROM_ARDUINO) {
        for (int i=0; i<serialInArray.length; i++) {
          arduino_values[i] = int(serialInArray[i]);
        }
      }
    }
  }
}

//ARDUINO OUTPUT
void sendSerialData() {
  String data = "";
  for (int i=0; i<processing_values.length; i++) {
    data += processing_values[i];
    // if i is less than the index number of the last element in the values array
    if (i < processing_values.length-1) {
      data += ",";  // add splitter character "," between each values element
    }
    // if it is the last element in the values array
    else {
      data += "\n";  // add the end of data character "n"
    }
  }
  // write to Arduino
  serialPort.write(data);
  print("To Arduino: " + data);  // this prints to the console the values going to Arduino
}
